<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Data Semantic Guard - Corruption Visualization</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        :root {
            --bg-primary: #0f0c29;
            --bg-secondary: #302b63;
            --bg-tertiary: #24243e;
            --text-primary: #ffffff;
            --text-secondary: #a0aec0;
            --accent-primary: #667eea;
            --accent-secondary: #764ba2;
            --card-bg: rgba(255, 255, 255, 0.05);
            --border-color: rgba(255, 255, 255, 0.1);
            --baseline-color: #667eea;
            --current-color: #fc8181;
            --grid-color: #444444;
            --success-color: #48bb78;
            --warning-color: #f6ad55;
            --error-color: #fc8181;
        }

        :root.theme-passing {
            --bg-primary: #0a2e1a;
            --bg-secondary: #1a4d2e;
            --bg-tertiary: #1e3a2a;
            --accent-primary: #48bb78;
            --accent-secondary: #38a169;
            --baseline-color: #4299e1;
            --current-color: #48bb78;
        }

        :root.theme-failing {
            --bg-primary: #2d0a1f;
            --bg-secondary: #4d1a34;
            --bg-tertiary: #3a1e2e;
            --accent-primary: #fc8181;
            --accent-secondary: #e53e3e;
            --baseline-color: #4299e1;
            --current-color: #fc8181;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, var(--bg-primary) 0%, var(--bg-secondary) 50%, var(--bg-tertiary) 100%);
            color: var(--text-primary);
            min-height: 100vh;
            overflow-x: hidden;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            text-align: center;
            padding: 40px 20px;
            background: var(--card-bg);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            margin-bottom: 30px;
            border: 1px solid var(--border-color);
        }

        h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            background: linear-gradient(45deg, var(--accent-primary) 0%, var(--accent-secondary) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .subtitle {
            color: var(--text-secondary);
            font-size: 1.1em;
        }

        .upload-zone {
            border: 3px dashed var(--accent-primary);
            border-radius: 15px;
            padding: 60px;
            text-align: center;
            cursor: pointer;
            background: var(--card-bg);
            margin-bottom: 30px;
            opacity: 0.6;
        }

        .upload-zone:hover {
            opacity: 1;
            transform: translateY(-2px);
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);
        }

        .upload-zone.dragover {
            border-color: var(--success-color);
            background: rgba(72, 187, 120, 0.1);
        }

        .upload-icon {
            font-size: 4em;
            margin-bottom: 20px;
            opacity: 0.7;
        }

        #fileInput {
            display: none;
        }

        .dashboard {
            display: none;
            animation: fadeIn 0.5s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .metric-card {
            background: var(--card-bg);
            backdrop-filter: blur(10px);
            padding: 25px;
            border-radius: 15px;
            border: 1px solid var(--border-color);
        }

        .metric-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);
        }

        .metric-label {
            color: var(--text-secondary);
            font-size: 0.9em;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .metric-value {
            font-size: 2.5em;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .metric-change {
            font-size: 0.9em;
            padding: 5px 10px;
            border-radius: 20px;
            display: inline-block;
        }

        .confidence-high { 
            color: var(--error-color);
            background: rgba(252, 129, 129, 0.15);
        }
        .confidence-medium { 
            color: var(--warning-color);
            background: rgba(246, 173, 85, 0.15);
        }
        .confidence-low { 
            color: var(--success-color);
            background: rgba(104, 211, 145, 0.15);
        }

        .visualization-container {
            background: var(--card-bg);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 30px;
            border: 1px solid var(--border-color);
        }

        .viz-header {
            margin-bottom: 20px;
        }

        .viz-title {
            font-size: 1.5em;
            font-weight: 600;
            margin-bottom: 10px;
        }

        .viz-description {
            color: var(--text-secondary);
            font-size: 0.95em;
            line-height: 1.6;
        }

        #threejs-container {
            width: 100%;
            height: 600px;
            border-radius: 10px;
            overflow: hidden;
            background: rgba(0, 0, 0, 0.4);
            position: relative;
        }

        .axis-labels {
            position: absolute;
            color: var(--text-secondary);
            font-size: 0.85em;
            font-weight: 500;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.8);
            pointer-events: none;
        }

        .axis-label-y {
            left: 20px;
            top: 50%;
            transform: translateY(-50%) rotate(-90deg);
            transform-origin: center;
        }

        .axis-label-x {
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
        }

        .legend {
            display: flex;
            gap: 30px;
            justify-content: center;
            margin-top: 20px;
            flex-wrap: wrap;
            padding: 15px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 0.95em;
        }

        .legend-color {
            width: 24px;
            height: 24px;
            border-radius: 4px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        .anomalies-section {
            background: rgba(252, 129, 129, 0.1);
            border: 1px solid var(--error-color);
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 30px;
        }

        .anomaly-item {
            background: var(--card-bg);
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 10px;
            border-left: 4px solid var(--error-color);
        }

        .stats-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }

        .stats-table th,
        .stats-table td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid var(--border-color);
        }

        .stats-table th {
            color: var(--accent-primary);
            font-weight: 600;
        }

        .status-badge {
            display: inline-block;
            padding: 8px 16px;
            border-radius: 20px;
            font-weight: bold;
            font-size: 0.9em;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .status-passed {
            background: rgba(72, 187, 120, 0.2);
            color: var(--success-color);
            border: 1px solid var(--success-color);
        }

        .status-failed {
            background: rgba(252, 129, 129, 0.2);
            color: var(--error-color);
            border: 1px solid var(--error-color);
        }

        .diagnostics-section {
            background: var(--card-bg);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 25px;
            border: 1px solid var(--border-color);
            white-space: pre-wrap;
            font-family: 'Courier New', monospace;
            line-height: 1.6;
            font-size: 0.9em;
        }

        .error-message {
            background: rgba(252, 129, 129, 0.2);
            border: 1px solid var(--error-color);
            color: var(--error-color);
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
        }

        .upload-btn {
            display: inline-block;
            padding: 12px 24px;
            background: var(--accent-primary);
            color: white;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            margin-top: 15px;
            border: none;
            font-size: 1em;
        }

        .upload-btn:hover {
            background: var(--accent-secondary);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .data-info {
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
            font-size: 0.9em;
            color: var(--text-secondary);
        }

        .data-info strong {
            color: var(--text-primary);
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üõ°Ô∏è Data Semantic Guard</h1>
            <p class="subtitle">Silent Data Corruption Visualization Dashboard</p>
        </header>

        <div class="upload-zone" id="uploadZone">
            <div class="upload-icon">üìä</div>
            <h2>Upload Corruption Report</h2>
            <p style="margin-top: 10px; color: var(--text-secondary);">
                Drag and drop your <code>silent-data-corruption-report.json</code> file here<br>
                or click to browse
            </p>
            <button class="upload-btn" onclick="document.getElementById('fileInput').click()">
                Choose File
            </button>
            <input type="file" id="fileInput" accept=".json">
            <div class="data-info">
                üí° <strong>Tip:</strong> Upload a new report to see live updates without redeploying
            </div>
        </div>

        <div class="dashboard" id="dashboard">
            <!-- Metrics Overview -->
            <div class="metrics-grid">
                <div class="metric-card">
                    <div class="metric-label">Confidence Score</div>
                    <div class="metric-value" id="confidenceScore">--</div>
                    <div class="metric-change" id="confidenceLabel">Unknown</div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">Status</div>
                    <div class="metric-value" style="font-size: 1.5em;">
                        <span id="statusBadge" class="status-badge">--</span>
                    </div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">Anomalies Detected</div>
                    <div class="metric-value" id="anomalyCount">--</div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">Analysis Type</div>
                    <div class="metric-value" style="font-size: 1.3em;" id="comparisonType">--</div>
                </div>
            </div>

            <!-- 3D Visualization -->
            <div class="visualization-container">
                <div class="viz-header">
                    <h2 class="viz-title">üìà Distribution Comparison Histogram</h2>
                    <p class="viz-description">
                        This histogram compares the statistical distribution of your <strong>baseline data</strong> (expected values) 
                        against <strong>current data</strong> (incoming values). Each bar represents the frequency of values 
                        falling within a specific range (bin). Significant differences in bar heights or positions indicate 
                        potential data corruption or semantic drift.
                    </p>
                </div>
                <div id="threejs-container">
                    <div class="axis-labels axis-label-y">Frequency (Count) ‚Üí</div>
                    <div class="axis-labels axis-label-x">‚Üê Value Range (Binned) ‚Üí</div>
                </div>
                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-color" id="baselineColorBox"></div>
                        <span><strong>Baseline Data</strong> - Expected distribution from historical data</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" id="currentColorBox"></div>
                        <span><strong>Current Data</strong> - Incoming data distribution being validated</span>
                    </div>
                </div>
                <div class="data-info" id="dataStats"></div>
            </div>

            <!-- Anomalies -->
            <div class="anomalies-section" id="anomaliesSection" style="display: none;">
                <h2 style="margin-bottom: 20px;">üö® Detected Anomalies</h2>
                <div id="anomaliesList"></div>
            </div>

            <!-- Statistics Comparison -->
            <div class="visualization-container">
                <h2 style="margin-bottom: 20px;">üìä Statistical Comparison</h2>
                <table class="stats-table">
                    <thead>
                        <tr>
                            <th>Metric</th>
                            <th>Baseline</th>
                            <th>Current</th>
                            <th>Change</th>
                        </tr>
                    </thead>
                    <tbody id="statsTableBody">
                    </tbody>
                </table>
            </div>

            <!-- Diagnostics -->
            <div class="diagnostics-section">
                <h2 style="margin-bottom: 20px;">üîç Diagnostic Report</h2>
                <div id="diagnosticsContent"></div>
            </div>
        </div>
    </div>

    <script>
        let scene, camera, renderer, animationId;
        let reportData = null;
        const uploadZone = document.getElementById('uploadZone');
        const fileInput = document.getElementById('fileInput');
        const dashboard = document.getElementById('dashboard');

        // File upload handling
        uploadZone.addEventListener('click', (e) => {
            if (e.target.tagName !== 'BUTTON') {
                fileInput.click();
            }
        });

        uploadZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadZone.classList.add('dragover');
        });

        uploadZone.addEventListener('dragleave', () => {
            uploadZone.classList.remove('dragover');
        });

        uploadZone.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadZone.classList.remove('dragover');
            const file = e.dataTransfer.files[0];
            if (file) processFile(file);
        });

        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) processFile(file);
        });

        function processFile(file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const data = JSON.parse(e.target.result);
                    console.log('Loaded report data:', data);
                    
                    if (!data.metadata || !data.baseline_stats || !data.current_stats) {
                        throw new Error('Invalid report format: missing required fields');
                    }
                    
                    reportData = data;
                    renderDashboard(reportData);
                    uploadZone.style.display = 'none';
                    dashboard.style.display = 'block';
                } catch (error) {
                    console.error('Error parsing file:', error);
                    alert('Error parsing JSON file: ' + error.message);
                }
            };
            reader.onerror = () => alert('Error reading file');
            reader.readAsText(file);
        }

        function applyTheme(status) {
            const root = document.documentElement;
            root.className = ''; // Clear existing theme
            
            if (status === 'PASSED') {
                root.classList.add('theme-passing');
            } else if (status === 'FAILED') {
                root.classList.add('theme-failing');
            }
            
            // Update legend colors to match theme
            const baselineColor = getComputedStyle(root).getPropertyValue('--baseline-color').trim();
            const currentColor = getComputedStyle(root).getPropertyValue('--current-color').trim();
            
            document.getElementById('baselineColorBox').style.background = baselineColor;
            document.getElementById('currentColorBox').style.background = currentColor;
        }

        function renderDashboard(data) {
            try {
                // Apply theme based on status
                applyTheme(data.status);

                // Render metrics
                const confidence = data.metadata.confidence_score || 0;
                document.getElementById('confidenceScore').textContent = confidence + '%';
                
                const confidenceLabel = document.getElementById('confidenceLabel');
                if (confidence >= 90) {
                    confidenceLabel.textContent = 'HIGH RISK';
                    confidenceLabel.className = 'metric-change confidence-high';
                } else if (confidence >= 70) {
                    confidenceLabel.textContent = 'MEDIUM RISK';
                    confidenceLabel.className = 'metric-change confidence-medium';
                } else {
                    confidenceLabel.textContent = 'LOW RISK';
                    confidenceLabel.className = 'metric-change confidence-low';
                }

                const statusBadge = document.getElementById('statusBadge');
                const status = data.status || 'UNKNOWN';
                statusBadge.textContent = status;
                statusBadge.className = status === 'FAILED' ? 'status-badge status-failed' : 'status-badge status-passed';

                const anomalies = data.detected_anomalies || [];
                document.getElementById('anomalyCount').textContent = anomalies.length;
                
                const compType = (data.metadata.comparison_type || 'unknown').replace(/_/g, ' ').toUpperCase();
                document.getElementById('comparisonType').textContent = compType;

                // Render anomalies
                if (anomalies.length > 0) {
                    document.getElementById('anomaliesSection').style.display = 'block';
                    const anomaliesList = document.getElementById('anomaliesList');
                    anomaliesList.innerHTML = anomalies
                        .map(anomaly => `<div class="anomaly-item">‚ö†Ô∏è ${anomaly}</div>`)
                        .join('');
                }

                // Render statistics table
                renderStatsTable(data.baseline_stats, data.current_stats);

                // Render diagnostics
                document.getElementById('diagnosticsContent').textContent = data.diagnostics || 'No diagnostics available';

                // Render data statistics summary
                const baselineData = data.sample_before || [];
                const currentData = data.sample_after || [];
                document.getElementById('dataStats').innerHTML = `
                    <strong>Dataset Information:</strong><br>
                    Baseline samples: ${baselineData.length} values | 
                    Current samples: ${currentData.length} values | 
                    Mean shift: ${((data.current_stats.mean - data.baseline_stats.mean) / data.baseline_stats.mean * 100).toFixed(1)}%
                `;

                // Render 3D visualization with DISTINCT datasets
                setTimeout(() => render3DVisualization(data), 100);
            } catch (error) {
                console.error('Error rendering dashboard:', error);
                dashboard.innerHTML = `<div class="error-message">Error rendering dashboard: ${error.message}</div>`;
            }
        }

        function renderStatsTable(baseline, current) {
            const metrics = ['mean', 'median', 'std_dev', 'min', 'max'];
            const tbody = document.getElementById('statsTableBody');
            
            tbody.innerHTML = metrics.map(metric => {
                const baseVal = baseline[metric] || 0;
                const currVal = current[metric] || 0;
                const change = baseVal !== 0 ? ((currVal - baseVal) / baseVal * 100).toFixed(1) : '0.0';
                const changeColor = Math.abs(change) > 50 ? 'var(--error-color)' : 
                                   Math.abs(change) > 20 ? 'var(--warning-color)' : 
                                   'var(--success-color)';
                
                return `
                    <tr>
                        <td><strong>${metric.replace(/_/g, ' ').toUpperCase()}</strong></td>
                        <td>${baseVal.toFixed(2)}</td>
                        <td>${currVal.toFixed(2)}</td>
                        <td style="color: ${changeColor};">${parseFloat(change) > 0 ? '+' : ''}${change}%</td>
                    </tr>
                `;
            }).join('');
        }

        function render3DVisualization(data) {
            const container = document.getElementById('threejs-container');
            
            // Clean up previous scene
            if (renderer) {
                cancelAnimationFrame(animationId);
                container.querySelector('canvas')?.remove();
            }

            try {
                if (typeof THREE === 'undefined') {
                    throw new Error('Three.js library not loaded');
                }

                // Get current theme colors
                const root = document.documentElement;
                const baselineColor = getComputedStyle(root).getPropertyValue('--baseline-color').trim();
                const currentColor = getComputedStyle(root).getPropertyValue('--current-color').trim();

                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x0a0a0a);
                
                const width = container.clientWidth;
                const height = container.clientHeight;
                
                camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
                camera.position.set(6, 6, 12);
                camera.lookAt(0, 2, 0);
                
                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(width, height);
                container.appendChild(renderer.domElement);

                // Lighting
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                scene.add(ambientLight);
                
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(10, 10, 10);
                scene.add(directionalLight);

                // CRITICAL FIX: Use DISTINCT datasets for each histogram
                const baselineData = data.sample_before || [];
                const currentData = data.sample_after || [];

                console.log('Rendering baseline histogram with:', baselineData.length, 'samples');
                console.log('Baseline data preview:', baselineData.slice(0, 5));
                
                console.log('Rendering current histogram with:', currentData.length, 'samples');
                console.log('Current data preview:', currentData.slice(0, 5));

                // Create histograms with SEPARATE datasets
                if (baselineData.length > 0) {
                    createHistogramBars(baselineData, -3, baselineColor, 'Baseline');
                }
                
                if (currentData.length > 0) {
                    createHistogramBars(currentData, 3, currentColor, 'Current');
                }

                // Add grid
                const gridHelper = new THREE.GridHelper(20, 20, 0x444444, 0x222222);
                scene.add(gridHelper);

                // Add axis helpers
                const axesHelper = new THREE.AxesHelper(5);
                scene.add(axesHelper);

                // Animation loop
                function animate() {
                    animationId = requestAnimationFrame(animate);
                    scene.rotation.y += 0.002;
                    renderer.render(scene, camera);
                }
                animate();

                // Handle window resize
                window.addEventListener('resize', () => {
                    if (!renderer) return;
                    const newWidth = container.clientWidth;
                    const newHeight = container.clientHeight;
                    camera.aspect = newWidth / newHeight;
                    camera.updateProjectionMatrix();
                    renderer.setSize(newWidth, newHeight);
                });

                console.log('3D visualization rendered successfully');
            } catch (error) {
                console.error('Error rendering 3D visualization:', error);
                container.innerHTML = `<div class="error-message">Error rendering 3D: ${error.message}</div>`;
            }
        }

        function createHistogramBars(dataArray, xOffset, colorHex, label) {
            if (!dataArray || dataArray.length === 0) {
                console.warn(`No data for ${label} histogram`);
                return;
            }

            try {
                // Filter numeric values
                const numericData = dataArray.filter(val => typeof val === 'number' && !isNaN(val));
                
                if (numericData.length === 0) {
                    console.warn(`No numeric data for ${label} histogram`);
                    return;
                }

                const bins = 10;
                const min = Math.min(...numericData);
                const max = Math.max(...numericData);
                
                console.log(`${label} histogram: min=${min}, max=${max}, samples=${numericData.length}`);
                
                // Handle edge case: all values identical
                if (min === max) {
                    const geometry = new THREE.BoxGeometry(0.4, 2, 0.4);
                    const material = new THREE.MeshPhongMaterial({ 
                        color: colorHex,
                        transparent: true,
                        opacity: 0.85
                    });
                    const bar = new THREE.Mesh(geometry, material);
                    bar.position.set(xOffset, 1, 0);
                    scene.add(bar);
                    console.log(`${label}: Single bar created (all values identical)`);
                    return;
                }
                
                const binWidth = (max - min) / bins;
                const histogram = new Array(bins).fill(0);
                
                // Populate histogram
                numericData.forEach(val => {
                    const binIndex = Math.min(Math.floor((val - min) / binWidth), bins - 1);
                    histogram[binIndex]++;
                });

                const maxCount = Math.max(...histogram);
                if (maxCount === 0) return;
                
                // Create bars
                let barsCreated = 0;
                histogram.forEach((count, i) => {
                    if (count === 0) return;
                    
                    const height = (count / maxCount) * 4;
                    const geometry = new THREE.BoxGeometry(0.4, height, 0.4);
                    const material = new THREE.MeshPhongMaterial({ 
                        color: colorHex,
                        transparent: true,
                        opacity: 0.85
                    });
                    const bar = new THREE.Mesh(geometry, material);
                    
                    bar.position.set(
                        xOffset + (i - bins / 2) * 0.5,
                        height / 2,
                        0
                    );
                    
                    scene.add(bar);
                    barsCreated++;
                });

                console.log(`${label}: Create <parameter name="old_str"> `);
                console.log(`${label}: Create</parameter> <parameter name="new_str">`);
                console.log(`${label}: Created ${barsCreated} histogram bars`);
            }
            catch (error) {
                console.error(`Error creating ${label} histogram:`, error);
            }
        }
    // Auto-load fallback data
    window.addEventListener('load', async () => {
        const reportPaths = [
            '../data/report/silent-data-corruption-report.json',
            'data/report/silent-data-corruption-report.json',
            './data/report/silent-data-corruption-report.json'
        ];
        
        for (const path of reportPaths) {
            try {
                console.log(`Trying to load report from: ${path}`);
                const response = await fetch(path);
                if (response.ok) {
                    const data = await response.json();
                    console.log('Auto-loaded fallback report from:', path);
                    reportData = data;
                    renderDashboard(reportData);
                    uploadZone.style.display = 'none';
                    dashboard.style.display = 'block';
                    return;
                }
            } catch (error) {
                console.log(`Failed to load from ${path}`);
            }
        }
        console.log('No fallback data available - waiting for user upload');
    });
</script>
</body>
</html></parameter>